# Fluentd 的优缺点

以前在不少场合轻度使用过 Fluentd，主要都是将日志汇聚到一个地方，它给我的大体印象是简单且能解决问题。直到最近在一个业务量稍大而且逻辑较复杂的场景下，我发现 Fluentd 的优点和缺点都挺明显的。

### 首先说优点

它的日志采集方式非常丰富，tail、http、命令等等，总能方便地将日志传到 Fluentd。特别是 tail 的方式，考虑到了包含日期的日志，日志的轮转等方面，让人觉得十分放心。

Fluentd 中 tag，label 这两个概念使得数据在其中流动可以实现灵活的逻辑处理，比如通过 `rewrite_tag_filter` 插件可以实现根据数据的内容修改此数据的 tag，然后这条数据会进入对应 tag 的处理逻辑；通过第三方插件 `record_splitter` 可以将数据内的数组元素拆分成多条数据；通过 `copy` 与 `relabel` 插件可以使得一条数据能复制到两条流水线上。

作为一个日志传输工具，Fluentd 考虑到了传输过程中很多问题的应对方法，比如接收方跟不上时的缓存，接收方不可达时的候选接收方（secondary），多个接收方的负载均衡。

还有就是它有丰富的插件，基本上想要的功能都有插件实现。因为插件都是 lua 脚本，编写的门槛很低，所以即使没有插件很多人也敢自己编写。

### 说完优点说说缺点

首先还是性能。Fluentd 的宣传里有高性能这一项，可能是相对于 logstash 的性能。在实际使用中，在 Fluentd 中做上面提及的 `rewrite_tag`, `split`, `copy` 然后写入数据库，单进程 2000 条日志也差不多极限了，CPU 100%，内存占用 2-3G。而且受限于 Ruby 的 GIL，它并不能多线程。多进程也受限于插件是否支持。

总之，Fluentd 的性能既因为 Ruby 消耗过多计算和内存资源，又因为 Ruby 难以受益与多核。对数据吞吐量大的业务来说它是很昂贵的。

灵活和性能并不完全是冲突的，比如 Nginx 足够灵活，性能也足够强。

除了性能，Fluentd 的插件质量也不够好，第三方插件大多是使用者根据自己业务需求编写的，只为实现特定需求，没有足够的泛化，也没有足够的测试和性能评估。不少常用的插件也以额外安装的方式添加，带来不必要的麻烦。

另外就是配置文件，一个 filter 里只能做一个转换，比如：

```
<filter a.tag>
    @type parse
    ...
</filter>
<filter a.tag>
    @type transform_record
    ...
</filter>
```

总觉得没有下面这样来的干脆

```
<filter a.tag>
    <item>
        @type parse
        ...
    </item>
    <item>
        @type stransform_record
        ...
    </item>
</filter>
```

### 最后

我觉得 Fluentd 用在数据量不大的场景还是很不错的，省心省事。

如果转换逻辑少当数据量很大，那可以进一步考虑 Fluentd 的小伙伴 Fluent-Bit，性能更高，占用资源少很多，就是插件少一点。

如果转换逻辑稍多，数据量很大，那可能可以在采集端使用 Fluentd/Fluent-Bit，数据汇聚处自己写程序。